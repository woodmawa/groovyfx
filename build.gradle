/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright 2011-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * SPDX-License-Identifier: Apache-2.0
 */
/*
 * GroovyFX - Gradle 9.1 build.gradle (Groovy DSL)
 * - Java toolchain 25
 * - Groovy 5 (BOM aligned)
 * - JavaFX 25 via org.openjfx.javafxplugin (also applied to demoImplementation)
 * - ast + demo sourceSets
 * - Asciidoctor docs + Jacoco
 * - Publishing + signing + nexus publish plugin
 */

import org.asciidoctor.gradle.jvm.AsciidoctorTask
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository
import org.gradle.plugins.signing.Sign

plugins {
    id 'groovy'
    id 'java-library'
    id 'idea'
    id 'jacoco'

    id 'org.openjfx.javafxplugin' version '0.1.0'

    id 'maven-publish'
    id 'signing'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0'

    id 'org.asciidoctor.jvm.convert' version '4.0.5'
}

/**
 * Project identity comes from gradle.properties:
 *   group=...
 *   version=...
 *   archivesBaseName=...
 */
base {
    archivesName.set(providers.gradleProperty('archivesBaseName').orElse('groovyfx-ng'))
}

/**
 * Versions from gradle.properties (your keys)
 */
ext {
    groovyVersion = providers.gradleProperty('groovyfx_groovyVersion').orElse('5.0.0').get()
    javafxVersion = providers.gradleProperty('groovyfx_javafxVersion').orElse('25.0.0').get()
    spockVersion  = providers.gradleProperty('groovyfx_spockVersion').orElse('2.4-M7-groovy-5.0').get()
    jansiVersion  = providers.gradleProperty('groovyfx_jansiVersion').orElse('2.4.1').get()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
    withSourcesJar()
    withJavadocJar()
}

/**
 * Source sets:
 * - ast contains FXBindable annotation + its AST transformation + META-INF services
 * - demo contains runnable demos/examples
 */
sourceSets {
    main {
        java.srcDirs = ['src/main/java']
        groovy.srcDirs = ['src/main/groovy']
        resources.srcDirs = ['src/main/resources']
    }

   demo {
        groovy.srcDirs = ['src/demo/groovy']
        resources.srcDirs = ['src/demo/resources']

        // demos must see main outputs
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

/**
 * Configurations:
 * - demoImplementation is declarable only (NOT resolvable)
 */
configurations {
    demoImplementation.extendsFrom(implementation)
    demoRuntimeOnly.extendsFrom(runtimeOnly)
}

/**
 * Dependencies
 */
dependencies {
    // Main Groovy alignment via BOM
    api platform("org.apache.groovy:groovy-bom:$groovyVersion")
    api "org.apache.groovy:groovy"

    // TEMP: SceneGraphBuilder imports groovy.swing.*; keep until refactor
    implementation "org.apache.groovy:groovy-swing"

    // Jansi
    implementation "org.fusesource.jansi:jansi:$jansiVersion"

    implementation("org.slf4j:slf4j-api:2.0.16")

    // Optional: only if you want log output at runtime (demos, running app, etc.)
    // runtimeOnly("org.slf4j:slf4j-simple:2.0.16")
    runtimeOnly("ch.qos.logback:logback-classic:1.5.16")

    // Tests
    testImplementation "org.spockframework:spock-core:$spockVersion"
    testImplementation "org.apache.groovy:groovy-test:$groovyVersion"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"

    // Demo runtime add-on (you had this)
    //demoImplementation 'jakarta.xml.bind:jakarta.xml.bind-api:4.0.2'
    //demoRuntimeOnly 'com.sun.xml.bind:jaxb-impl:4.0.5'


}

/**
 * JavaFX wiring:
 * Let the OpenJFX plugin add JavaFX deps (incl. platform classifiers).
 * IMPORTANT: include demoImplementation so demo runners get JavaFX too.
 */
javafx {
    version = javafxVersion
    modules = [
            'javafx.base',
            'javafx.graphics',
            'javafx.controls',
            'javafx.fxml',
            'javafx.web',
            'javafx.media',
            'javafx.swing'
    ]

    // ADD astImplementation here
    configurations = [
            'implementation',
            'testImplementation',
            'demoImplementation'
    ]
}

/**
 * JPMS: compile module-info *after* Groovy has produced classes, so exports/opens resolve.
 */
tasks.named('compileJava', JavaCompile).configure {
    // definitive: compileJava will never see module-info.java
    source = sourceSets.main.java.matching {
        exclude('**/module-info.java')
    }
}

/*
tasks.named('compileJava').configure {
    exclude('module-info.java')
}
*/

tasks.withType(JavaCompile).configureEach {
    modularity.inferModulePath = true
}

tasks.withType(GroovyCompile).configureEach {
    // no patch-module here
}

import org.gradle.api.tasks.compile.AbstractCompile

tasks.withType(AbstractCompile).configureEach {
    doFirst {
        // DirectoryProperty -> File
        destinationDirectory.getAsFile().get().mkdirs()
    }
}

/**
 * Dedicated module-info compilation step (after classes exist)
 */
def moduleName = 'org.groovyfx'
def moduleInfoDir = file('src/module-info/java')

tasks.register('compileModuleInfo', JavaCompile) {
    dependsOn tasks.named('classes')

    source = fileTree(moduleInfoDir) { include 'module-info.java' }
    destinationDirectory = layout.buildDirectory.dir('classes/java/module-info')

    def mp = sourceSets.main.compileClasspath
    classpath = files()

    options.release = 25
    options.compilerArgs += [
            '--module-path', mp.asPath,
            '--patch-module', "org.groovyfx=${sourceSets.main.output.classesDirs.asPath}"
    ]
}

tasks.named('jar').configure {
    dependsOn tasks.named('compileModuleInfo')
    from(tasks.named('compileModuleInfo')) {
        include 'module-info.class'
    }
}

/**
 * Tests
 */
tasks.withType(Test).configureEach {
    useJUnitPlatform()
    jvmArgs += [
            '--enable-native-access=ALL-UNNAMED',
    ]
}


//configure the demo runners to use the MOdule system
/*
tasks.withType(JavaExec).configureEach {
    // This forces Gradle to use --module-path instead of -classpath
    modularity.inferModulePath = true

    jvmArgs += [
            "--patch-module", "org.groovyfx=${sourceSets.demo.output.classesDirs.asPath}"
    ]
}
*/


def demoRunClasspath = {
    files(
            tasks.named('jar').flatMap { it.archiveFile },
            sourceSets.demo.runtimeClasspath - sourceSets.main.output
    )
}

/**
 * Demo runners (Gradle 9 style)
 */
tasks.register('ModernDashboard', JavaExec) {
    group = "Examples"
    description = "Runs the ModernDashboard example"

    dependsOn tasks.named('jar'), tasks.named('demoClasses')

    modularity.inferModulePath = true

    // IMPORTANT:
    // - DO NOT set mainModule
    // - main class lives on classpath
    mainClass.set("examples.ModernDashboard")

    classpath = demoRunClasspath()

}

tasks.register('ResponsiveForm', JavaExec) {
    group = "Examples"
    description = "Runs the Responsive Form example"

    dependsOn tasks.named('jar'), tasks.named('demoClasses')

    modularity.inferModulePath = true

    // IMPORTANT:
    // - demo main class is NOT in the module
    // - do NOT set mainModule
    mainClass.set("examples.ResponsiveForm")

    classpath = demoRunClasspath()
}

/**
 * IDEA integration
 * Avoid resolving demoImplementation; use resolvable demoCompileClasspath/demoRuntimeClasspath.
 */
idea {
    module {
        sourceDirs += sourceSets.demo.groovy.srcDirs
        resourceDirs += sourceSets.demo.resources.srcDirs

        scopes.COMPILE.plus += [configurations.demoCompileClasspath]
        scopes.RUNTIME.plus += [configurations.demoRuntimeClasspath]
    }
}

/**
 * Asciidoctor docs
 * Assumes docs live under src/docs/asciidoc (as in your project structure)
 */
tasks.named("asciidoctor", AsciidoctorTask).configure { t ->
    t.sourceDir = layout.projectDirectory.dir("src/docs/asciidoc").asFile

    t.sources {
        include("**/*.adoc")
    }

    t.outputDir = layout.buildDirectory.dir("docs/asciidoc").get().asFile
    t.baseDirFollowsSourceDir()

    t.resources {
        from(t.sourceDir) {
            include("images/**")
            include("css/**")
        }
    }

    t.attributes(
            "stylesheet": "style.css",
            "stylesdir": "css"
    )
}

tasks.named("build").configure {
    dependsOn(tasks.named("asciidoctor"))
}

/**
 * JaCoCo
 */
jacoco {
    toolVersion = '0.8.14'
}

/**
 * Publishing
 */
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java

            pom {
                name.set(providers.gradleProperty('pomName').orElse('GroovyFX'))
                description.set(providers.gradleProperty('pomDescription')
                        .orElse('GroovyFX next-generation builder for JavaFX 25 + Groovy 5'))
                url.set(providers.gradleProperty('pomUrl').orElse('https://github.com/woodmawa/groovyfx'))

                licenses {
                    license {
                        name.set('The Apache License, Version 2.0')
                        url.set('https://www.apache.org/licenses/LICENSE-2.0.txt')
                    }
                }

                developers {
                    developer {
                        id.set(providers.gradleProperty('pomDeveloperId').orElse('woodmawa'))
                        name.set(providers.gradleProperty('pomDeveloperName').orElse('woodmawa'))
                        email.set(providers.gradleProperty('pomDeveloperEmail').orElse(''))
                    }
                }

                scm {
                    connection.set(providers.gradleProperty('pomScmConnection')
                            .orElse('scm:git:https://github.com/woodmawa/groovyfx.git'))
                    developerConnection.set(providers.gradleProperty('pomScmDeveloperConnection')
                            .orElse('scm:git:ssh://git@github.com:woodmawa/groovyfx.git'))
                    url.set(providers.gradleProperty('pomScmUrl')
                            .orElse('https://github.com/woodmawa/groovyfx'))
                }
            }
        }
    }
}

/**
 * Credentials / Signing
 */
def sonatypeUsername = (findProperty('sonatypeUsername') ?: System.getenv('SONATYPE_USERNAME'))?.toString()
def sonatypePassword = (findProperty('sonatypePassword') ?: System.getenv('SONATYPE_PASSWORD'))?.toString()
def signingKey       = (findProperty('signingKey')       ?: System.getenv('SIGNING_KEY'))?.toString()
def signingPassword  = (findProperty('signingPassword')  ?: System.getenv('SIGNING_PASSWORD'))?.toString()

signing {
    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
    }
    sign publishing.publications.mavenJava
}

/**
 * Fail-fast checks for Sonatype publish actions
 */
def isMavenLocalInvocation = gradle.startParameter.taskNames.any { it.toLowerCase().contains('mavenlocal') }
def isCentralInvocation = !isMavenLocalInvocation && gradle.startParameter.taskNames.any { t ->
    def n = t.toLowerCase()
    n.contains('sonatype') || n.contains('mavencentral') || n.contains('staging') ||
            n == 'publish' || n.endsWith(':publish')
}

def requireCentralSecrets = { String action ->
    def missing = []
    if (!sonatypeUsername || !sonatypePassword) missing << "Sonatype credentials (sonatypeUsername/sonatypePassword or env)"
    if (!signingKey || !signingPassword) missing << "Signing key (signingKey/signingPassword or env)"
    if (!missing.isEmpty()) {
        throw new GradleException("Cannot run '${action}' without: ${missing.join('; ')}")
    }
}

def validateCentralSecrets = tasks.register('validateCentralSecrets') {
    group = 'publishing'
    description = 'Validates Sonatype + signing secrets for Maven Central publishing.'
    onlyIf { isCentralInvocation }
    doLast { requireCentralSecrets(path) }
}

tasks.withType(Sign).configureEach { t ->
    onlyIf { isCentralInvocation }
    dependsOn(validateCentralSecrets)
}

tasks.withType(PublishToMavenRepository).configureEach { t ->
    if (t.repository?.name == 'sonatype') {
        t.doFirst { requireCentralSecrets(t.path) }
    }
}

/**
 * Nexus publish plugin
 */
nexusPublishing {
    repositories {
        sonatype {
            username = providers.gradleProperty('sonatypeUsername').orNull ?: sonatypeUsername
            password = providers.gradleProperty('sonatypePassword').orNull ?: sonatypePassword
        }
    }
}

/**
 * Convenience alias:
 *   ./gradlew publishToMavenCentral
 */
tasks.register('publishToMavenCentral') {
    group = 'publishing'
    description = 'Publishes to Sonatype/Maven Central (snapshots go to snapshots repo; releases are staged then closed+released).'

    dependsOn tasks.named('publish')

    if (!version.toString().endsWith('-SNAPSHOT')) {
        finalizedBy tasks.named('closeAndReleaseSonatypeStagingRepository')
    }
}

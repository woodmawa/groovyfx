/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright 2011-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * SPDX-License-Identifier: Apache-2.0
 */

import org.asciidoctor.gradle.jvm.AsciidoctorTask

plugins {
    id 'groovy'
    id 'java-library'
    id 'idea'
    id 'jacoco'
    id 'org.openjfx.javafxplugin' version '0.1.0'

    id 'maven-publish'
    id 'signing'
    // Root-project plugin that manages Sonatype staging repositories + publish/close/release automation
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0'

    id "org.asciidoctor.jvm.convert" version "4.0.5"

}

group = (findProperty('group') ?: 'org.groovyfx') as String
version = (findProperty('version') ?: '0.0.0-SNAPSHOT') as String

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
    withJavadocJar()
    withSourcesJar()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    // JavaFX 25 requires JDK 23+, so target 23 bytecode for widest compatibility.
    options.release = 23
}

asciidoctorj {
    // try bumping JRuby; exact chosen version may still be higher due to transitive deps
    jrubyVersion = "10.0.0.0"
}

// Configure the generated 'asciidoctor' task explicitly
tasks.named("asciidoctor", AsciidoctorTask).configure { t ->
    t.sourceDir = layout.projectDirectory.dir("src/docs/asciidoc").asFile

    t.sources {
        include("**/*.adoc")
        // or only the guide:
        // include("component_authoring_guide.adoc")
    }

    t.outputDir = layout.buildDirectory.dir("docs/asciidoc").get().asFile

    t.baseDirFollowsSourceDir()

    t.resources {
        from(t.sourceDir) {
            include("images/**")
            include("css/**")
        }
    }

    // Use your custom stylesheet in src/docs/asciidoc/css/style.css
    t.attributes(
            "stylesheet": "style.css",
            "stylesdir": "css"
    )
}

// Example tasks
task ModernDashboard(type: JavaExec) {
    group = "Examples"
    description = "Runs the Modern Dashboard example"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'examples.ModernDashboard'
}

task ResponsiveForm(type: JavaExec) {
    group = "Examples"
    description = "Runs the Responsive Form example"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'examples.ResponsiveForm'
}

// Optional: generate docs as part of build
tasks.named("build").configure {
    dependsOn(tasks.named("asciidoctor"))
}

jacoco {
    toolVersion = '0.8.14'
}


repositories {
    mavenCentral()
    // optionally enable this for local testing:
    // if (findProperty('groovyfx_useMavenLocal')?.toString()?.toBoolean()) mavenLocal()
}

def groovyVersion = (findProperty('groovyfx_groovyVersion') ?: '5.0.3') as String
def javafxVersion = (findProperty('groovyfx_javafxVersion') ?: '25.0.1') as String
def spockVersion  = (findProperty('groovyfx_spockVersion')  ?: '2.4-M7-groovy-5.0') as String
def jansiVersion  = (findProperty('groovyfx_jansiVersion')  ?: '2.4.1') as String

javafx {
    version = javafxVersion
    // keep broad module set for GroovyFX (trim later once build is green)
    modules = [
            'javafx.base',
            'javafx.graphics',
            'javafx.controls',
            'javafx.fxml',
            'javafx.web',
            'javafx.media'
    ]
}

/**
 * AST bootstrap:
 * - compileAstGroovy must produce FXBindable + FXBindableASTTransformation before main sources compile
 * - Avoid compileAstJava/compileAstGroovy cycles by doing JOINT compilation in compileAstGroovy:
 *   * ast Groovy srcDirs include src/ast/groovy AND src/ast/java (so Java AST transform compiles there)
 *   * ast Java srcDirs is EMPTY (so compileAstJava is NO-SOURCE)
 */
sourceSets {
    ast {
        groovy.srcDirs = ['src/ast/groovy', 'src/ast/java']
        java.srcDirs   = [] // critical: prevents compileAstJava sources & avoids task cycles
        resources.srcDirs = ['src/ast/resources']

        // allow AST compilation to reuse normal dependencies if needed
        compileClasspath += sourceSets.main.compileClasspath
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    astImplementation.extendsFrom implementation
    astCompileOnly.extendsFrom compileOnly
    astRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    // AST source set needs Groovy too (separate source set = separate classpath)
    astImplementation platform("org.apache.groovy:groovy-bom:${groovyVersion}")
    astImplementation "org.apache.groovy:groovy"

    // Use Groovy 5 BOM to keep Groovy modules aligned
    api platform("org.apache.groovy:groovy-bom:${groovyVersion}")
    api "org.apache.groovy:groovy"

    // TEMP: SceneGraphBuilder imports groovy.swing.*; keep until we refactor it out
    //implementation "org.apache.groovy:groovy-swing"

    // JavaFX dependencies are supplied by org.openjfx plugin via the 'javafx { }' block

    // Jansi (legacy console support)
    implementation "org.fusesource.jansi:jansi:${jansiVersion}"

    // Testing (Spock runs on JUnit Platform)
    testImplementation platform("org.apache.groovy:groovy-bom:${groovyVersion}")
    testImplementation "org.spockframework:spock-core:${spockVersion}"
    testImplementation("org.apache.groovy:groovy-test:${spockVersion}")
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"
}

// Ensure main compilation sees the compiled AST output (annotation + transform)
tasks.named('compileGroovy', GroovyCompile).configure {
    dependsOn(tasks.named('compileAstGroovy'))
    classpath += sourceSets.ast.output
}
tasks.named('compileJava', JavaCompile).configure {
    dependsOn(tasks.named('compileAstGroovy'))
    classpath += sourceSets.ast.output
}

tasks.withType(GroovyCompile).configureEach {
    groovyOptions.encoding = 'UTF-8'
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.release = 25
}

test {
    useJUnitPlatform()
}

// IntelliJ/Gradle sometimes calls 'version' task; keep it around
tasks.register("version") {
    group = "Help"
    description = "Prints the project version."
    doLast {
        println(project.version)
    }
}

// Make AST (FXBindable + transform) visible to tests too
tasks.named('compileTestGroovy', GroovyCompile).configure {
    dependsOn(tasks.named('compileAstGroovy'))
    classpath += sourceSets.ast.output
}

tasks.named('compileTestJava', JavaCompile).configure {
    dependsOn(tasks.named('compileAstGroovy'))
    classpath += sourceSets.ast.output
}

// avoid instrumenting JDK internals and similar
tasks.withType(Test).configureEach {
    jacoco {
        excludes = ['java/**', 'javax/**', 'jdk/**', 'sun/**', 'com/sun/**']
    }
}

//hide native access warnings - clearer to read
tasks.withType(Test).configureEach {
    jvmArgs '--enable-native-access=ALL-UNNAMED'
}

/**
 * -----------------------------
 * Credentials / Signing inputs
 * -----------------------------
 *
 * Prefer:
 *  - Gradle properties (e.g. in ~/.gradle/gradle.properties):
 *      sonatypeUsername=...
 *      sonatypePassword=...
 *      signingKey=...            (ASCII-armored private key)
 *      signingPassword=...
 *
 * Or environment variables:
 *      ORG_GRADLE_PROJECT_sonatypeUsername / ORG_GRADLE_PROJECT_sonatypePassword (Gradle auto-maps)
 *      SONATYPE_USERNAME / SONATYPE_PASSWORD
 *      SIGNING_KEY / SIGNING_PASSWORD
 */
def sonatypeUsername = (findProperty('sonatypeUsername') ?: System.getenv('SONATYPE_USERNAME'))?.toString()
def sonatypePassword = (findProperty('sonatypePassword') ?: System.getenv('SONATYPE_PASSWORD'))?.toString()
def signingKey       = (findProperty('signingKey')       ?: System.getenv('SIGNING_KEY'))?.toString()
def signingPassword  = (findProperty('signingPassword')  ?: System.getenv('SIGNING_PASSWORD'))?.toString()

// Optional override (defaults are the Central Portal endpoints recommended by Sonatype)
def centralStagingNexusUrl = (findProperty('centralStagingNexusUrl')
        ?: 'https://ossrh-staging-api.central.sonatype.com/service/local/').toString()
def centralSnapshotsUrl = (findProperty('centralSnapshotsUrl')
        ?: 'https://central.sonatype.com/repository/maven-snapshots/').toString()

/**
 * -----------------------------
 * Maven publishing
 * -----------------------------
 *
 * NOTE:
 *  - We deliberately DO NOT declare publishing.repositories.maven { ... } for Sonatype here.
 *  - The Gradle Nexus Publish Plugin creates & wires the repository based on the nexusPublishing { ... } block.
 *  - publishToMavenLocal keeps working without credentials.
 */
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java

            pom {
                name = (project.findProperty('pomName') ?: project.name).toString()
                description = (project.findProperty('pomDescription') ?: 'TODO: Project description').toString()
                url = (project.findProperty('pomUrl') ?: 'https://example.com/').toString()

                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'https://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }

                developers {
                    developer {
                        id = (project.findProperty('pomDeveloperId') ?: 'TODO').toString()
                        name = (project.findProperty('pomDeveloperName') ?: 'TODO').toString()
                        email = (project.findProperty('pomDeveloperEmail') ?: 'TODO@example.com').toString()
                    }
                }

                scm {
                    connection = (project.findProperty('pomScmConnection') ?: 'scm:git:https://example.com/your/repo.git').toString()
                    developerConnection = (project.findProperty('pomScmDeveloperConnection') ?: 'scm:git:https://example.com/your/repo.git').toString()
                    url = (project.findProperty('pomScmUrl') ?: 'https://example.com/your/repo').toString()
                }
            }
        }
    }
}

/**
 * -----------------------------
 * Sonatype (Maven Central) wiring
 * -----------------------------
 *
 * The plugin will:
 *  - create a Maven repo named 'sonatype'
 *  - for release versions: create a staging repo, publish into it, then you can close/release it
 *  - for snapshots: publish to the snapshots repo
 *
 * Credentials can be supplied via:
 *  - project properties: sonatypeUsername / sonatypePassword
 *  - ORG_GRADLE_PROJECT_sonatypeUsername / ORG_GRADLE_PROJECT_sonatypePassword env vars (preferred)
 *  - or SONATYPE_USERNAME / SONATYPE_PASSWORD env vars (supported here)
 */
nexusPublishing {
    repositories {
        sonatype {
            nexusUrl.set(uri(centralStagingNexusUrl))
            snapshotRepositoryUrl.set(uri(centralSnapshotsUrl))

            // If these are null, we'll fail-fast *only when* you run a Central-related task.
            if (sonatypeUsername) username = sonatypeUsername
            if (sonatypePassword) password = sonatypePassword
        }
    }
}

/**
 * -----------------------------
 * Signing
 * -----------------------------
 *
 * Maven Central requires signed artifacts for most OSS releases.
 * publishToMavenLocal does not require signing.
 */
signing {
    // Configure in-memory PGP key if present. (Works well in CI.)
    // NOTE: Signing tasks are conditionally executed (see below) so local publishing doesn't require keys.
    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
    }
    sign publishing.publications.mavenJava
}


import org.gradle.plugins.signing.Sign

/**
 * -----------------------------
 * Conditional signing
 * -----------------------------
 *
 * - publishToMavenLocal should never require signing.
 * - Central/Sonatype publishing should require signing keys (fail-fast with a clear message).
 */
def isMavenLocalInvocation = gradle.startParameter.taskNames.any { it.toLowerCase().contains('mavenlocal') }
def isCentralInvocation = !isMavenLocalInvocation && gradle.startParameter.taskNames.any { t ->
    def n = t.toLowerCase()
    n.contains('sonatype') || n.contains('mavencentral') || n.contains('staging') ||
            // running 'publish' without an explicit local target is treated as a remote publish attempt
            n == 'publish' || n.endsWith(':publish')
}

// Validate secrets *before* any signing task starts, so we don't get "no configured signatory" errors.
def validateCentralSecrets = tasks.register('validateCentralSecrets') {
    group = 'publishing'
    description = 'Validates Sonatype + signing secrets for Maven Central publishing.'
    onlyIf { isCentralInvocation }
    doLast {
        // This closure is defined below; we call it here after it's declared.
        requireCentralSecrets(path)
    }
}

// Signing tasks:
//  - skipped for local invocations
//  - depend on validateCentralSecrets for Central invocations (so we fail with a clear error)
tasks.withType(Sign).configureEach { t ->
    onlyIf { isCentralInvocation }
    dependsOn(validateCentralSecrets)
}

/**
 * -----------------------------
 * Fail-fast checks (Gradle 9.x friendly)
 * -----------------------------
 *
 * Instead of relying on taskGraph inspection (which is configuration-cache unfriendly),
 * we validate at task execution time for tasks that actually publish to Sonatype / manage staging.
 */
def requireCentralSecrets = { String action ->
    def missing = []
    if (!sonatypeUsername || !sonatypePassword) missing << "Sonatype credentials (sonatypeUsername/sonatypePassword or env)"
    if (!signingKey || !signingPassword) missing << "Signing key (signingKey/signingPassword or env)"
    if (!missing.isEmpty()) {
        logger.warn("Maven Central action requested (${action}), but required secrets are missing: ${missing.join(', ')}")
        throw new GradleException("Cannot run '${action}' without: ${missing.join('; ')}")
    }
}

// Any publish task that targets the Sonatype repo should require credentials/signing.
tasks.withType(org.gradle.api.publish.maven.tasks.PublishToMavenRepository).configureEach { t ->
    if (t.repository?.name == 'sonatype') {
        t.doFirst { requireCentralSecrets(t.path) }
    }
}

// Nexus publish plugin tasks (close/release, etc.) should also require credentials/signing.
tasks.matching { it.name.toLowerCase().contains('staging') || it.name.toLowerCase().contains('sonatype') }.configureEach { t ->
    // Skip purely diagnostic tasks if you want, but safest to guard all staging actions:
    t.doFirst {
        // Don't block help/tasks listing or local-only flows.
        if (gradle.startParameter.taskNames.any { it.toLowerCase().contains('mavenlocal') }) return
        requireCentralSecrets(t.path)
    }
}

/**
 * Convenience alias:
 *  ./gradlew publishToMavenCentral
 *
 * This will:
 *  - publish (to staging or snapshots depending on version)
 *  - then close & release staging repos for non-SNAPSHOT versions
 */
tasks.register('publishToMavenCentral') {
    group = 'publishing'
    description = 'Publishes to Sonatype/Maven Central (snapshots go to snapshot repo; releases are staged then closed+released).'

    dependsOn 'publish' // includes publishMavenJavaPublicationToSonatypeRepository (created by nexus publish plugin)

    // For releases (non -SNAPSHOT), close & release after publishing.
    if (!version.toString().endsWith('-SNAPSHOT')) {
        finalizedBy 'closeAndReleaseSonatypeStagingRepository'
    }
}


